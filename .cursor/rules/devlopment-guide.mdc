---
description: Project-wide development guide and coding standards for Flutter architecture
globs:
  - "lib/**/*.dart"
alwaysApply: true
---

# Development Guide & Coding Standards

This file integrates the comprehensive development guide for the project.
Refer to the main documentation file: `DEVELOPMENT_GUIDE.md`

## ğŸ—ï¸ Clean Architecture Layers

```
lib/
â”œâ”€â”€ core/                          # Shared functionality
â”‚   â”œâ”€â”€ network/                   # Dio, error handling
â”‚   â”œâ”€â”€ theming/                   # Colors, text styles
â”‚   â”œâ”€â”€ widgets/                   # Reusable UI components
â”‚   â”œâ”€â”€ helpers/                   # Utilities
â”‚   â”œâ”€â”€ routing/                   # Navigation
â”‚   â””â”€â”€ services/                  # Dependency injection
â””â”€â”€ features/                      # Feature modules
    â””â”€â”€ [feature-name]/
        â”œâ”€â”€ presentation/          # UI Layer
        â”‚   â”œâ”€â”€ screens/
        â”‚   â””â”€â”€ components/
        â”œâ”€â”€ controller/            # Business Logic
        â”‚   â””â”€â”€ cubit/
        â””â”€â”€ data/                  # Data Layer
            â”œâ”€â”€ models/
            â”œâ”€â”€ repositories/
            â””â”€â”€ remote_data_sources/
```

## ğŸ¨ Theming Standards

### Colors
```dart
// Always use ColorsManager for colors
Container(color: ColorsManager.primary)
Text(style: TextStyle(color: ColorsManager.textPrimary))
```

### Text Styles
```dart
// Always use TextStyles for typography
Text('Hello', style: TextStyles.font16Black500)
Text('Title', style: TextStyles.font24Black700)
```

### Responsive Design
```dart
// ALWAYS use flutter_screenutil
Container(
  width: 200.w,              // .w for width
  height: 100.h,             // .h for height
  padding: EdgeInsets.all(16.w),
  child: Text('Hello', style: TextStyle(fontSize: 14.sp)), // .sp for font
)

// Border radius
BorderRadius.circular(12.r)  // .r for radius
```

## ğŸ›ï¸ State Management Pattern

### Cubit Structure
```dart
class FeatureCubit extends Cubit<FeatureState> {
  FeatureCubit(this.repository) : super(const FeatureState());

  final BaseFeatureRepository repository;

  Future<void> loadData() async {
    emit(state.copyWith(status: FeatureStatus.loading));

    final result = await repository.getData();
    result.fold(
      (error) => emit(state.copyWith(
        status: FeatureStatus.error,
        errorMessage: error.message,
      )),
      (data) => emit(state.copyWith(
        status: FeatureStatus.success,
        data: data.responseObject,
      )),
    );
  }
}
```

### State Structure
```dart
enum FeatureStatus { initial, loading, success, error }

class FeatureState {
  final FeatureStatus status;
  final List<DataModel> data;
  final String? errorMessage;
  final String? successMessage;

  const FeatureState({
    this.status = FeatureStatus.initial,
    this.data = const [],
    this.errorMessage,
    this.successMessage,
  });

  FeatureState copyWith({...}) { ... }

  // Helper getters
  bool get isLoading => status == FeatureStatus.loading;
  bool get hasError => status == FeatureStatus.error;
  bool get hasData => data.isNotEmpty;
}
```

## ğŸŒ Network Layer Pattern

### Repository Pattern
```dart
abstract class BaseFeatureRepository {
  Future<Either<ApiErrorModel, ApiResponse<T>>> getData();
}

class FeatureRepository implements BaseFeatureRepository {
  final BaseFeatureRemoteDataSource remoteDataSource;
  FeatureRepository(this.remoteDataSource);

  @override
  Future<Either<ApiErrorModel, ApiResponse<T>>> getData() async {
    try {
      final result = await remoteDataSource.getData();
      return Right(result);
    } on FailException catch (e) {
      return Left(FailHandler.instance.handleError(e.exception));
    }
  }
}
```

### Remote Data Source Pattern
```dart
abstract class BaseFeatureRemoteDataSource {
  Future<ApiResponse<List<DataModel>>> getData();
}

class FeatureRemoteDataSource implements BaseFeatureRemoteDataSource {
  @override
  Future<ApiResponse<List<DataModel>>> getData() async {
    try {
      final response = await DioHelper.instance.get('endpoint/path');

      if (response.data['status'] == 0) {
        final List<dynamic> dataList = response.data['responseObject'] ?? [];
        final List<DataModel> models = dataList
            .map((json) => DataModel.fromJson(json))
            .toList();

        return ApiResponse.fromJson(response.data, models);
      } else {
        throw FailException(
          exception: response.data['responseText'] ?? 'Request failed',
        );
      }
    } catch (e) {
      throw FailException(exception: e);
    }
  }
}
```

## ğŸ¯ Dependency Injection

### Service Locator Pattern
```dart
// Cubits - Factory (new instance each time)
getIt.registerFactory<FeatureCubit>(() => FeatureCubit(getIt()));

// Repositories - Singleton (shared instance)
getIt.registerLazySingleton<BaseFeatureRepository>(
  () => FeatureRepository(getIt())
);

// Remote Data Sources - Singleton
getIt.registerLazySingleton<BaseFeatureRemoteDataSource>(
  () => FeatureRemoteDataSource(DioHelper.instance)
);
```

## ğŸ“± Screen Structure

### BlocProvider Setup
```dart
class FeatureScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => getIt<FeatureCubit>()..loadData(),
      child: _FeatureView(),
    );
  }
}
```

### BlocConsumer Pattern
```dart
class _FeatureView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocConsumer<FeatureCubit, FeatureState>(
      listenWhen: (previous, current) =>
        previous.status != current.status,
      listener: (context, state) {
        if (state.hasError) {
          showSnackBar(state.errorMessage!, context, false);
        }
      },
      buildWhen: (previous, current) =>
        previous.status != current.status || previous.data != current.data,
      builder: (context, state) {
        if (state.isLoading) {
          return Center(child: CupertinoActivityIndicator());
        }
        return _buildContent(state);
      },
    );
  }
}
```

## ğŸ§­ Navigation

### Routes Definition
```dart
class Routes {
  static const String landing = '/landing';
  static const String featureScreen = '/feature';
}
```

### Navigation Usage
```dart
// Push with route name
context.pushNamed(Routes.featureScreen);

// Push with arguments
context.pushNamed(Routes.featureDetails, arguments: data);

// Pass existing cubit
Navigator.pushNamed(
  context,
  Routes.detailsScreen,
  arguments: context.read<FeatureCubit>(),
);
```

## ğŸ”§ Data Models

### Model Structure
```dart
class DataModel {
  final int id;
  final String name;
  final bool isActive;

  DataModel({
    required this.id,
    required this.name,
    required this.isActive,
  });

  factory DataModel.fromJson(Map<String, dynamic> json) {
    return DataModel(
      id: json['id'] as int? ?? 0,
      name: json['name'] as String? ?? '',
      isActive: json['isActive'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'isActive': isActive,
    };
  }

  DataModel copyWith({
    int? id,
    String? name,
    bool? isActive,
  }) {
    return DataModel(
      id: id ?? this.id,
      name: name ?? this.name,
      isActive: isActive ?? this.isActive,
    );
  }
}
```

## âš¡ Performance Best Practices

### Optimized BlocBuilder
```dart
BlocBuilder<FeatureCubit, FeatureState>(
  buildWhen: (previous, current) =>
    previous.relevantField != current.relevantField, // Only rebuild when needed
  builder: (context, state) => YourWidget(),
)
```

### Efficient Lists
```dart
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) {
    final item = items[index];
    return ItemWidget(
      key: ValueKey(item.id), // Keys for efficient updates
      item: item,
    );
  },
)
```

## ğŸ“ Naming Conventions

- **Files**: `snake_case.dart`
- **Classes**: `PascalCase`
- **Variables/Methods**: `camelCase`
- **Constants**: `camelCase` with `static const`
- **Private members**: `_prefixWithUnderscore`

## ğŸš¨ Error Handling Rules

1. **Always use Either** for repository methods
2. **Handle both network and unexpected errors**
3. **Provide meaningful error messages**
4. **Use FailException** for consistent error propagation
5. **Show loading states** during API calls
6. **Implement retry mechanisms** for failed operations

## ğŸ¯ Key Principles

1. **Separation of Concerns**: UI, Business Logic, Data layers separate
2. **Single Responsibility**: Each class has one purpose
3. **Dependency Injection**: Use GetIt for loose coupling
4. **State Management**: Use Cubit/Bloc for business logic
5. **Reusability**: Create reusable widgets and utilities
6. **Responsive Design**: Use flutter_screenutil consistently
7. **Performance**: Optimize rebuilds with buildWhen

## ğŸ› ï¸ Common Utilities

### Spacing Helper
```dart
verticalSpace(16.h)      // SizedBox(height: 16.h)
horizontalSpace(12.w)    // SizedBox(width: 12.w)
```

### Validation
```dart
ValidationHelpers.validateRequired(value, 'Field Name')
ValidationHelpers.validateEmail(value)
```

---

**For complete details, refer to**: `DEVELOPMENT_GUIDE.md`